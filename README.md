# data-structure-3
## 5 串  
### 5.1 定义与比较与存储结构  
又叫字符串，零或多个字符组成的有限数列  
s=“a1a2a3......an"(n>=0)  
几个概念：空串，空格串，子串，主串  
子串在主串中的位置就是子串的第一个字符在主串中的序号  
两个字符串的比较大小：例如s=”happ“，t=”happy“，就有s<t;再例如s=”happen“，t=”happy“，前四个字母都相同，但是s的第五个字母e的ASCII码是101，而t的y的ASCII码是121，则e<y，因此s<t  
两个字符串相等：1.长度相等;2.各个对应位置字符串相等  
线性表更关注的是对于单个元素的操作，而字符串更关注的是对于子串的操作，查找子串位置，替换，插入等  
串的存储结构与线性表相同，分为顺序存储结构和链式存储结构，但是链式存储结构不如顺序灵活
### 5.2 朴素模式匹配算法  
简而言之：主串大循环，子串小循环，直到匹配成功，时间复杂度为O((n-m+1)xm)非常低效  
返回子串T在主串S中的第pos个字符后的位置，如果不存在，函数则返回0（假设主串s和要子串T的长度存在S[0]与T[0]中）  
```
int Index(String S, String T, int pos)
{
int i=pos;  //i表示主串s的下标
int j=1;  //j表示子串T的下标
while(i<=S[0] && j<=L[0])
{
  if(S[i]=T[j])  //如果两字母相等则继续遍历
  {
    ++i;
    ++j;
  }
  else
  {
  i=i-j+2;  //否则i退回上次匹配位置的下一位
  j=1;  //j退回T的起始位置
  }
}
if(j>T[0])
  return(i-T[0])
else
  return 0;
}
```
### 5.3 KMP模式匹配算法  
关键：根据子串T和T的当前位置下标j推导next[j]数组  
```
void get_next(string T, int *next)
{
int i=1,j=1;  //T[j]表示前缀的单个字符，T[i]表示后缀的单个字符  
next[1]=0;
while(i<T[0])
{
  if(T[i]==T[j])
  {
    ++i;
    ++j;
    next[i]=j-1;
  }
  else
    j=next[j];
}
}
```
